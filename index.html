<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Space Dino v5.3</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0f172a;
            font-family: 'Orbitron', sans-serif;
            touch-action: none;
        }

        canvas { display: block; }

        .game-text-shadow { text-shadow: 0px 0px 10px rgba(6, 182, 212, 0.8); }
        .hazard-text-shadow { text-shadow: 0px 0px 10px rgba(239, 68, 68, 0.8); }
        .void-text-shadow { text-shadow: 0px 0px 15px #a855f7; }
        .rescue-text-shadow { text-shadow: 0px 0px 10px #22c55e; }
        .jungle-text-shadow { text-shadow: 0px 0px 10px #facc15; } /* Yellow for Jungle */
        
        @keyframes pulse-alert {
            0% { opacity: 0; transform: scale(0.9); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0; transform: scale(1.1); }
        }
        .space-alert { animation: pulse-alert 2.5s infinite; }

        .neon-btn {
            background: linear-gradient(45deg, #7c3aed, #06b6d4);
            border: 2px solid #a78bfa;
            box-shadow: 0 0 15px #7c3aed;
        }
        .neon-btn:active {
            box-shadow: 0 0 5px #7c3aed;
            transform: translateY(2px);
        }
    </style>
</head>
<body>

    <!-- UI Layer -->
    <div id="ui-layer" class="absolute inset-0 pointer-events-none flex flex-col justify-between p-4 z-10">
        
        <!-- Header -->
        <div class="flex justify-between items-start w-full">
            <div class="text-white">
                <h1 class="text-2xl md:text-3xl tracking-widest text-purple-400 font-bold italic" style="text-shadow: 0 0 10px #a78bfa;">SPACE DINO</h1>
                <div class="text-sm text-cyan-200">BEST: <span id="best-score">0</span>m</div>
                <div id="zone-display" class="text-xs text-yellow-400 mt-1 uppercase tracking-widest font-bold">ATMOSPHERE</div>
            </div>
            <div class="text-right">
                <div id="score-display" class="text-5xl md:text-6xl text-white game-text-shadow">0<span class="text-2xl">m</span></div>
                <div id="speed-display" class="text-cyan-400 text-sm font-mono">0 km/h</div>
                <div id="rider-status" class="text-green-400 text-xs font-bold tracking-widest mt-1">CO-PILOT: ACTIVE</div>
            </div>
        </div>

        <!-- Space Warning -->
        <div id="space-warning" class="absolute top-1/4 left-0 w-full text-center hidden">
            <div id="alert-title" class="text-4xl text-red-500 hazard-text-shadow space-alert font-bold">WARNING</div>
            <div id="alert-subtitle" class="text-white text-sm mt-2 tracking-widest">HAZARD DETECTED</div>
        </div>

        <!-- Screens -->
        <div id="message-area" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-center w-full px-4 transition-opacity duration-500">
            <div id="start-screen" class="pointer-events-auto bg-slate-900/80 p-8 rounded-xl border border-purple-500/50 backdrop-blur-sm">
                <div class="mb-6 animate-pulse">
                     <svg class="w-24 h-24 mx-auto text-purple-500" viewBox="0 0 100 100" fill="currentColor">
                        <path d="M60 15 C 65 15, 75 20, 75 30 C 75 35, 70 40, 65 40 L 60 40 L 60 50 L 70 50 C 75 50, 80 55, 80 60 C 80 70, 70 80, 50 80 C 40 80, 30 75, 25 60 C 20 60, 15 65, 15 70 L 15 50 C 15 35, 30 25, 45 20 L 45 15 Z" />
                        <circle cx="65" cy="25" r="3" fill="#06b6d4" />
                    </svg>
                </div>
                <h2 class="text-3xl text-white mb-2 font-bold tracking-widest">INITIATE LAUNCH</h2>
                <p class="text-purple-200 text-sm mb-8 font-mono">TAP TO GRAPPLE // PROTECT THE PILOT</p>
                <button id="start-btn" class="neon-btn text-white text-xl py-3 px-12 rounded-none transform skew-x-[-10deg] transition">
                    START MISSION
                </button>
            </div>

            <div id="game-over-screen" class="hidden pointer-events-auto bg-slate-900/90 p-8 rounded-xl border border-red-500/50 backdrop-blur-sm">
                <h2 class="text-4xl text-red-500 mb-2 hazard-text-shadow font-bold">MISSION FAILED</h2>
                <p id="death-reason" class="text-red-200 text-lg mb-2 font-mono">SIGNAL LOST</p>
                <p id="final-score" class="text-white text-2xl mb-6">DISTANCE: 0m</p>
                <button id="restart-btn" class="neon-btn text-white text-xl py-3 px-12 rounded-none transform skew-x-[-10deg] transition">
                    RETRY
                </button>
            </div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        /**
         * SPACE DINO v5.3 (Sloth Update)
         * - Added Large Sloth hazards in Rainforest mode after 1000 score.
         */

        const CONFIG = {
            gravity: 0.25,      
            airDrag: 0.995,     
            swingForce: 0.85,
            maxRopeLength: 400,
            minRopeLength: 40,
            cameraSmoothness: 0.1,
            dashCooldown: 120, 
            dashForce: { x: 15, y: -8 },
            spaceThreshold: 10000, 
            starThreshold: 20000,
            blackHoleThreshold: 50000,
            rescueDistance: 300,
            bonusLevelThreshold: 50, 
            slothThreshold: 1000, // Score in Jungle to see sloths
        };

        const AudioSys = {
            ctx: null,
            init: function() {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
            },
            playTone: function(freq, type, duration, vol = 0.1, slideTo = null) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                if (slideTo) {
                    osc.frequency.linearRampToValueAtTime(slideTo, this.ctx.currentTime + duration);
                }
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            playSwing: function() { this.playTone(300, 'sawtooth', 0.2, 0.05, 100); }, 
            playAttach: function() { this.playTone(800, 'square', 0.05, 0.05); }, 
            playDash: function() { this.playTone(200, 'sawtooth', 0.3, 0.1, 800); }, 
            playCrash: function() { this.playTone(100, 'sawtooth', 0.5, 0.3, 20); }, 
            playSpaceEnter: function() { this.playTone(600, 'sine', 1.5, 0.05, 1200); },
            playVoidHum: function() { this.playTone(50, 'sine', 1.0, 0.2, 30); },
            playEject: function() { this.playTone(1000, 'sawtooth', 0.4, 0.2, 100); }, 
            playRescue: function() { this.playTone(400, 'sine', 0.2, 0.1, 800); },
            playJungleEnter: function() { this.playTone(300, 'triangle', 2.0, 0.1, 500); } 
        };

        class Camera {
            constructor() {
                this.x = 0;
                this.y = 0;
                this.targetX = 0;
                this.targetY = 0;
            }
            update(dinoX, dinoY, width, height) {
                this.targetX = dinoX - width * 0.3;
                this.targetY = dinoY - height * 0.5;
                if (this.targetY > 200) this.targetY = 200; 
                
                this.x += (this.targetX - this.x) * CONFIG.cameraSmoothness;
                this.y += (this.targetY - this.y) * CONFIG.cameraSmoothness;
            }
        }

        class Hazard {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type; 
                this.active = true; 
                
                this.radius = 10;
                this.angle = Math.random() * Math.PI;
                this.rotationSpeed = (Math.random() - 0.5) * 0.05;
                
                // --- Space Hazards ---
                if (type === 'asteroid') {
                    this.radius = 20 + Math.random() * 20;
                    this.points = [];
                    const vertices = 7;
                    for(let i=0; i<vertices; i++) {
                        const theta = (i / vertices) * Math.PI * 2;
                        const r = this.radius * (0.7 + Math.random() * 0.5);
                        this.points.push({x: Math.cos(theta) * r, y: Math.sin(theta) * r});
                    }
                }

                if (type === 'comet') {
                    this.vx = -10 - Math.random() * 5; 
                    this.vy = (Math.random() - 0.5) * 4;
                    this.trail = [];
                }

                if (type === 'shootingStar') {
                    this.vx = -20 - Math.random() * 10; 
                    this.vy = 5 + Math.random() * 5; 
                    this.radius = 6; 
                    this.trail = [];
                }

                if (type === 'blackHole') {
                    this.radius = 35; 
                    this.gravityRadius = 400; 
                    this.swirlAngle = 0;
                    this.strength = 1.8; 
                }

                if (type === 'rescuePod') {
                    this.radius = 25;
                }

                // --- Jungle Hazards ---
                if (type === 'frog') {
                    this.radius = 15;
                    this.baseY = y;
                    this.hopOffset = Math.random() * 1000;
                }

                if (type === 'snake') {
                    this.radius = 12;
                    this.vx = -4 - Math.random() * 2; // Slower than comets
                    this.snakeWiggle = 0;
                }

                if (type === 'sloth') {
                    this.radius = 35; // Big obstacle
                    this.vx = -0.5; // Very slow
                    this.swingAngle = 0;
                }
            }

            update() {
                this.angle += this.rotationSpeed;
                
                if (this.type === 'comet' || this.type === 'shootingStar') {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.trail.push({x: this.x, y: this.y, life: 1.0});
                    const fadeSpeed = this.type === 'shootingStar' ? 0.08 : 0.1;
                    for(let i=this.trail.length-1; i>=0; i--) {
                        this.trail[i].life -= fadeSpeed;
                        if(this.trail[i].life <= 0) this.trail.splice(i, 1);
                    }
                }

                if (this.type === 'blackHole') {
                    this.swirlAngle += 0.1;
                }
                
                if (this.type === 'rescuePod') {
                    this.y += Math.sin(Date.now() / 300) * 0.5; 
                }

                if (this.type === 'frog') {
                    // Hop physics (Sine wave abs)
                    const time = Date.now() + this.hopOffset;
                    const hopHeight = 80;
                    const hopSpeed = 0.005;
                    this.y = this.baseY - Math.abs(Math.sin(time * hopSpeed)) * hopHeight;
                }

                if (this.type === 'snake') {
                    this.x += this.vx;
                    this.snakeWiggle += 0.2;
                    this.y += Math.sin(this.snakeWiggle) * 2; // Slither motion
                }

                if (this.type === 'sloth') {
                    this.x += this.vx;
                    this.swingAngle = Math.sin(Date.now() / 1500) * 0.15; // Slow sway
                }
            }

            draw(ctx) {
                if (!this.active && this.type !== 'rescuePod') return; 

                ctx.save();
                ctx.translate(this.x, this.y);

                if (this.type === 'blackHole') {
                    ctx.rotate(this.swirlAngle);
                    const grad = ctx.createRadialGradient(0, 0, this.radius, 0, 0, this.radius * 2.5);
                    grad.addColorStop(0, '#7c3aed'); 
                    grad.addColorStop(0.5, '#06b6d4'); 
                    grad.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = grad;
                    for(let i=0; i<3; i++) {
                        ctx.rotate((Math.PI * 2) / 3);
                        ctx.beginPath();
                        ctx.ellipse(0, 0, this.radius * 2.5, this.radius * 0.8, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.resetTransform(); 
                    ctx.translate(this.x, this.y);
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI*2);
                    ctx.fillStyle = '#000';
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#a78bfa';
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.stroke();

                } else if (this.type === 'rescuePod') {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(34, 197, 94, 0.2)'; 
                    ctx.fill();
                    ctx.strokeStyle = '#22c55e';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(0, -5, 4, 0, Math.PI*2); 
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(0, 5, 5, 8, 0, 0, Math.PI*2); 
                    ctx.fill();

                } else if (this.type === 'frog') {
                    // Poison Frog Visuals
                    ctx.fillStyle = '#a3e635'; // Lime green
                    ctx.beginPath();
                    ctx.ellipse(0, 5, 12, 10, 0, 0, Math.PI*2); // Body
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(-6, -2, 4, 0, Math.PI*2); // Eye L
                    ctx.arc(6, -2, 4, 0, Math.PI*2); // Eye R
                    ctx.fill();
                    ctx.fillStyle = '#000'; // Pupil
                    ctx.beginPath();
                    ctx.arc(-6, -2, 1.5, 0, Math.PI*2);
                    ctx.arc(6, -2, 1.5, 0, Math.PI*2);
                    ctx.fill();
                    // Spots
                    ctx.fillStyle = '#ef4444'; // Red poison spots
                    ctx.beginPath();
                    ctx.arc(0, 5, 3, 0, Math.PI*2);
                    ctx.fill();

                } else if (this.type === 'snake') {
                    // Snake Visuals
                    ctx.fillStyle = '#22c55e'; // Green
                    ctx.beginPath();
                    // Simple wavy body
                    for(let i=0; i<30; i+=5) {
                        ctx.arc(i, Math.sin(i + this.snakeWiggle)*2, 6, 0, Math.PI*2);
                    }
                    ctx.fill();
                    // Head
                    ctx.fillStyle = '#166534';
                    ctx.beginPath();
                    ctx.arc(-5, 0, 8, 0, Math.PI*2);
                    ctx.fill();
                    // Tongue
                    ctx.strokeStyle = '#ef4444';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-10, 0);
                    ctx.lineTo(-20, 0);
                    ctx.stroke();

                } else if (this.type === 'sloth') {
                    ctx.rotate(this.swingAngle);
                    
                    // The Vine holding the sloth
                    ctx.strokeStyle = '#3f6212'; // Dark olive
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, -600); // Goes way up
                    ctx.stroke();

                    // Sloth Body (Hanging upside down)
                    ctx.fillStyle = '#78350f'; // Brown
                    // Back legs holding on
                    ctx.beginPath();
                    ctx.arc(-10, -5, 8, 0, Math.PI*2);
                    ctx.fill();
                    // Front legs holding on
                    ctx.beginPath();
                    ctx.arc(10, -5, 8, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Main Body
                    ctx.beginPath();
                    ctx.ellipse(0, 15, 20, 28, 0, 0, Math.PI*2);
                    ctx.fill();

                    // Head
                    ctx.beginPath();
                    ctx.arc(0, 45, 12, 0, Math.PI*2);
                    ctx.fillStyle = '#92400e'; 
                    ctx.fill();

                    // Face
                    ctx.fillStyle = '#fde68a'; // Cream face
                    ctx.beginPath();
                    ctx.ellipse(0, 48, 8, 6, 0, 0, Math.PI*2);
                    ctx.fill();

                    // Sleepy Eyes
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-4, 48);
                    ctx.lineTo(-2, 48);
                    ctx.moveTo(2, 48);
                    ctx.lineTo(4, 48);
                    ctx.stroke();

                } else {
                    ctx.rotate(this.angle);

                    if (this.type === 'asteroid') {
                        ctx.beginPath();
                        ctx.moveTo(this.points[0].x, this.points[0].y);
                        for(let i=1; i<this.points.length; i++) {
                            ctx.lineTo(this.points[i].x, this.points[i].y);
                        }
                        ctx.closePath();
                        ctx.fillStyle = '#334155'; 
                        ctx.fill();
                        ctx.strokeStyle = '#475569';
                        ctx.stroke();
                        
                    } else if (this.type === 'comet') {
                        ctx.rotate(-this.angle); 
                        ctx.translate(-this.x, -this.y); 
                        this.trail.forEach(p => {
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, this.radius * p.life, 0, Math.PI*2);
                            ctx.fillStyle = `rgba(248, 113, 113, ${p.life})`; 
                            ctx.fill();
                        });
                        ctx.translate(this.x, this.y);
                        ctx.rotate(this.angle);
                        ctx.beginPath();
                        ctx.arc(0, 0, this.radius, 0, Math.PI*2);
                        ctx.fillStyle = '#ef4444'; 
                        ctx.fill();

                    } else if (this.type === 'shootingStar') {
                        ctx.rotate(-this.angle);
                        ctx.translate(-this.x, -this.y);
                        if (this.trail.length > 1) {
                             ctx.beginPath();
                             ctx.moveTo(this.trail[0].x, this.trail[0].y);
                             for(let p of this.trail) ctx.lineTo(p.x, p.y);
                             const grad = ctx.createLinearGradient(this.x, this.y, this.x - this.vx*5, this.y - this.vy*5);
                             grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                             grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                             ctx.strokeStyle = grad;
                             ctx.lineWidth = 4;
                             ctx.stroke();
                        }
                        ctx.translate(this.x, this.y);
                        ctx.rotate(this.angle);
                        ctx.beginPath();
                        ctx.arc(0, 0, this.radius, 0, Math.PI*2);
                        ctx.fillStyle = '#ffffff';
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#fff';
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                }

                ctx.restore();
            }
        }

        class Dino {
            constructor(x, y) {
                this.pos = { x: x, y: y };
                this.vel = { x: 5, y: 0 };
                this.radius = 15;
                this.angle = 0;
                this.state = 'falling';
                this.grapplePoint = null;
                this.ropeLength = 0;
                this.dashTimer = 0;
                
                this.hasRider = true;
                this.lostRiderAt = 0;
                this.invulnerableTimer = 0;
                this.spaghettified = false;
            }

            update(gameWidth, hazards) {
                this.vel.y += CONFIG.gravity;
                this.vel.x *= CONFIG.airDrag;
                this.vel.y *= CONFIG.airDrag;

                if (this.invulnerableTimer > 0) this.invulnerableTimer--;

                if (hazards) {
                    for(let h of hazards) {
                        if (h.type === 'blackHole') {
                            const dx = h.x - this.pos.x;
                            const dy = h.y - this.pos.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);

                            if (dist < h.gravityRadius) {
                                const force = h.strength * 2000 / (dist * dist + 100); 
                                const angle = Math.atan2(dy, dx);
                                this.vel.x += Math.cos(angle) * force;
                                this.vel.y += Math.sin(angle) * force;
                            }
                        }
                    }
                }

                if (this.grapplePoint) {
                    const dx = this.pos.x - this.grapplePoint.x;
                    const dy = this.pos.y - this.grapplePoint.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);

                    if (dist > this.ropeLength) {
                        const angle = Math.atan2(dy, dx);
                        const diff = dist - this.ropeLength;
                        this.pos.x -= Math.cos(angle) * diff * 0.5;
                        this.pos.y -= Math.sin(angle) * diff * 0.5;
                        this.vel.x -= Math.cos(angle) * CONFIG.swingForce;
                        this.vel.y -= Math.sin(angle) * CONFIG.swingForce;
                        
                        const speed = Math.sqrt(this.vel.x**2 + this.vel.y**2);
                        if (speed > 40) {
                            const ratio = 40 / speed;
                            this.vel.x *= ratio;
                            this.vel.y *= ratio;
                        }
                    }
                }

                this.pos.x += this.vel.x;
                this.pos.y += this.vel.y;

                if (this.dashTimer > 0) this.dashTimer--;

                if (this.grapplePoint) {
                    const dx = this.grapplePoint.x - this.pos.x;
                    const dy = this.grapplePoint.y - this.pos.y;
                    this.angle = Math.atan2(dy, dx) + Math.PI / 2;
                } else {
                    this.angle = Math.atan2(this.vel.y, this.vel.x) + Math.PI / 2;
                    if (this.angle > 0.5) this.angle = 0.5;
                    if (this.angle < -0.5) this.angle = -0.5;
                }
            }

            grapple(anchors) {
                if (this.grapplePoint) return; 
                let bestAnchor = null;
                let minDist = Infinity;
                for (let anchor of anchors) {
                    if (anchor.x < this.pos.x - 50) continue;
                    const dx = anchor.x - this.pos.x;
                    const dy = anchor.y - this.pos.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < CONFIG.maxRopeLength && dist > CONFIG.minRopeLength) {
                        let score = dist;
                        if (anchor.x > this.pos.x) score -= 50;
                        if (anchor.y < this.pos.y) score -= 100;
                        if (score < minDist) {
                            minDist = score;
                            bestAnchor = anchor;
                        }
                    }
                }
                if (bestAnchor) {
                    this.grapplePoint = bestAnchor;
                    const dx = this.pos.x - bestAnchor.x;
                    const dy = this.pos.y - bestAnchor.y;
                    this.ropeLength = Math.sqrt(dx*dx + dy*dy);
                    this.state = 'swinging';
                    AudioSys.playAttach();
                }
            }

            release() {
                this.grapplePoint = null;
                this.state = 'falling';
            }

            dash() {
                if (this.dashTimer === 0) {
                    this.vel.x += CONFIG.dashForce.x;
                    this.vel.y += CONFIG.dashForce.y;
                    this.dashTimer = CONFIG.dashCooldown;
                    AudioSys.playDash();
                    return true;
                }
                return false;
            }

            loseRider(currentScore) {
                this.hasRider = false;
                this.lostRiderAt = currentScore;
                this.invulnerableTimer = 120; 
                AudioSys.playEject();
            }

            recoverRider() {
                this.hasRider = true;
                AudioSys.playRescue();
            }

            draw(ctx, isBonusLevel) {
                if (this.spaghettified) return;

                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.rotate(this.angle);

                if (this.invulnerableTimer > 0 && Math.floor(Date.now() / 50) % 2 === 0) {
                    ctx.globalAlpha = 0.5;
                }

                // --- PURPLE CYBER-DINO ---
                const dinoPurple = '#7c3aed'; 
                const dinoLightPurple = '#a78bfa';
                const cyberNeon = isBonusLevel ? '#facc15' : '#06b6d4'; // Yellow in jungle, Cyan in space

                // Jetpack
                ctx.beginPath();
                ctx.roundRect(-10, -5, 6, 16, 2);
                ctx.fillStyle = '#334155';
                ctx.fill();
                ctx.beginPath();
                ctx.arc(-7, 12, 2, 0, Math.PI*2);
                ctx.fillStyle = cyberNeon;
                ctx.fill();

                // Tail
                ctx.beginPath();
                ctx.moveTo(-5, 5);
                ctx.quadraticCurveTo(-15, 20 + Math.sin(Date.now()/100)*5, -5, 25);
                ctx.lineTo(5, 5);
                ctx.fillStyle = dinoPurple;
                ctx.fill();

                // Body
                ctx.beginPath();
                ctx.ellipse(0, 0, 15, 20, 0, 0, Math.PI * 2);
                ctx.fillStyle = dinoPurple;
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(4, 2, 6, 10, 0, 0, Math.PI * 2);
                ctx.fillStyle = dinoLightPurple;
                ctx.fill();

                // Head
                ctx.beginPath();
                ctx.roundRect(-8, -28, 24, 20, 6);
                ctx.fillStyle = dinoPurple;
                ctx.fill();

                // Cyber Eye
                ctx.beginPath();
                ctx.arc(4, -20, 4, 0, Math.PI * 2);
                ctx.fillStyle = cyberNeon;
                ctx.fill();
                ctx.beginPath();
                ctx.arc(6, -20, 1.5, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();
                
                // Arm
                ctx.beginPath();
                ctx.roundRect(8, -5, 8, 4, 2);
                ctx.fillStyle = dinoPurple;
                ctx.fill();

                // Legs
                const legOffset = Math.sin(Date.now() / 50) * 3;
                ctx.beginPath();
                ctx.roundRect(-8, 15, 6, 12 + (this.state === 'running' ? legOffset : 0), 2);
                ctx.fillStyle = '#5b21b6'; 
                ctx.fill();
                ctx.beginPath();
                ctx.roundRect(2, 18, 6, 12 - (this.state === 'running' ? legOffset : 0), 2);
                ctx.fillStyle = dinoPurple;
                ctx.fill();

                if (this.hasRider) {
                    this.drawRider(ctx);
                }

                if (this.dashTimer > CONFIG.dashCooldown - 10) {
                     ctx.beginPath();
                     ctx.moveTo(-7, 12);
                     ctx.lineTo(-15, 25);
                     ctx.lineTo(0, 25);
                     ctx.fillStyle = isBonusLevel ? '#fef08a' : 'rgba(6, 182, 212, 0.8)';
                     ctx.fill();
                }

                ctx.restore();
            }

            drawRider(ctx) {
                // Adjusted position: further back and slightly up
                const rx = -12;
                const ry = -25;
                const bounce = Math.sin(Date.now() / 150);

                ctx.fillStyle = '#000000'; // Simple Black Silhouette

                // -- Hair (Curly Mass) --
                ctx.beginPath();
                // Top volume
                ctx.arc(rx - 2, ry - 5 + bounce, 7, 0, Math.PI * 2);
                // Back/Side curls falling down
                ctx.arc(rx - 6, ry + bounce, 6, 0, Math.PI * 2);
                ctx.arc(rx - 5, ry + 7 + bounce, 6, 0, Math.PI * 2);
                ctx.arc(rx, ry + 6 + bounce, 5.5, 0, Math.PI * 2);
                ctx.fill();

                // -- Body --
                ctx.beginPath();
                ctx.ellipse(rx + 2, ry + 14 + bounce, 7, 10, -0.3, 0, Math.PI * 2);
                ctx.fill();

                // -- Head --
                ctx.beginPath();
                ctx.arc(rx + 2, ry - 1 + bounce, 7, 0, Math.PI * 2);
                ctx.fill();

                // -- Arm --
                ctx.beginPath();
                ctx.ellipse(rx + 8, ry + 9 + bounce, 3, 8, 0.6, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                
                this.uiScore = document.getElementById('score-display');
                this.uiSpeed = document.getElementById('speed-display');
                this.uiBest = document.getElementById('best-score');
                this.uiZone = document.getElementById('zone-display');
                this.uiRider = document.getElementById('rider-status');
                
                this.uiSpaceAlert = document.getElementById('space-warning');
                this.uiAlertTitle = document.getElementById('alert-title');
                this.uiAlertSub = document.getElementById('alert-subtitle');
                
                this.screens = {
                    start: document.getElementById('start-screen'),
                    gameover: document.getElementById('game-over-screen'),
                    container: document.getElementById('message-area')
                };

                this.dino = null;
                this.camera = new Camera();
                this.anchors = [];
                this.hazards = [];
                this.particles = [];
                this.stars = [];
                this.jungleTreesBack = [];
                this.jungleTreesFront = [];
                this.jungleClouds = [];
                
                this.isRunning = false;
                this.score = 0;
                this.highScore = localStorage.getItem('space-dino-hs') || 0;
                this.uiBest.innerText = Math.floor(this.highScore);
                this.lastTime = 0;
                this.inputState = { holding: false, lastTap: 0 };
                this.alertState = 0; 
                this.rescueSpawned = false;
                this.isBonusLevel = false;
                
                this.resize();
                window.addEventListener('resize', () => this.resize());
                
                const handleStart = (e) => {
                    if(e.type !== 'mousedown') e.preventDefault(); 
                    if (!this.isRunning) return;

                    const now = Date.now();
                    const timeSinceLast = now - this.inputState.lastTap;
                    if (timeSinceLast < 300 && timeSinceLast > 50) {
                        this.dino.dash();
                    } else {
                        this.inputState.holding = true;
                        this.dino.grapple(this.anchors);
                    }
                    this.inputState.lastTap = now;
                };

                const handleEnd = (e) => {
                    if(e.type !== 'mouseup') e.preventDefault();
                    if (!this.isRunning) return;
                    this.inputState.holding = false;
                    this.dino.release();
                    AudioSys.playSwing();
                };

                this.canvas.addEventListener('mousedown', handleStart);
                this.canvas.addEventListener('touchstart', handleStart, {passive: false});
                this.canvas.addEventListener('mouseup', handleEnd);
                this.canvas.addEventListener('touchend', handleEnd, {passive: false});

                document.getElementById('start-btn').addEventListener('click', () => {
                    AudioSys.init();
                    this.startGame();
                });
                document.getElementById('restart-btn').addEventListener('click', () => {
                    this.startGame();
                });

                this.generateStars();
                this.generateJungleBackground();
                this.loop = this.loop.bind(this);
                requestAnimationFrame(this.loop);
            }

            resize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                this.generateStars();
                this.generateJungleBackground();
            }

            generateStars() {
                this.stars = [];
                for(let i=0; i<150; i++) {
                    this.stars.push({
                        x: Math.random() * this.width,
                        y: Math.random() * this.height,
                        size: Math.random() * 2,
                        alpha: Math.random(),
                        depth: Math.random() 
                    });
                }
            }

            generateJungleBackground() {
                this.jungleTreesBack = [];
                this.jungleTreesFront = [];
                this.jungleClouds = [];

                // Back trees (slower, darker)
                for(let i=0; i<this.width/100; i++) {
                    this.jungleTreesBack.push({
                        x: Math.random() * this.width,
                        y: this.height,
                        width: 20 + Math.random() * 30,
                        height: 300 + Math.random() * 400,
                        color: '#022c22'
                    });
                }

                // Front trees (faster, slightly lighter)
                for(let i=0; i<this.width/200; i++) {
                    this.jungleTreesFront.push({
                        x: Math.random() * this.width,
                        y: this.height,
                        width: 30 + Math.random() * 40,
                        height: 400 + Math.random() * 500,
                        color: '#065f46'
                    });
                }

                // Clouds
                for(let i=0; i<8; i++) {
                    this.jungleClouds.push({
                        x: Math.random() * this.width,
                        y: Math.random() * this.height * 0.4,
                        radius: 40 + Math.random() * 60,
                        speed: 0.1 + Math.random() * 0.3
                    });
                }
            }

            startGame() {
                this.dino = new Dino(100, 0);
                this.dino.vel.x = 10; 
                this.dino.vel.y = -5;
                
                this.anchors = [];
                this.hazards = [];
                this.particles = [];
                this.score = 0;
                this.isRunning = true;
                this.alertState = 0;
                this.isBonusLevel = false;
                
                this.uiSpaceAlert.classList.add('hidden');
                if (this.uiRider) {
                    this.uiRider.innerText = "CO-PILOT: ACTIVE";
                    this.uiRider.className = "text-green-400 text-xs font-bold tracking-widest mt-1";
                }
                
                this.generateLevel(0);
                this.screens.container.classList.add('opacity-0', 'pointer-events-none');
                setTimeout(() => {
                    this.screens.start.classList.add('hidden');
                    this.screens.gameover.classList.add('hidden');
                }, 500);
            }

            startBonusLevel() {
                this.isBonusLevel = true;
                this.dino = new Dino(100, 0);
                this.dino.vel.x = 10;
                this.dino.vel.y = -5;
                
                this.anchors = [];
                this.hazards = [];
                this.score = 0; // Reset score for bonus? Or keep accumulating? Let's reset for fresh run
                this.isRunning = true;
                
                // Clear UI
                this.uiSpaceAlert.classList.add('hidden');
                this.uiZone.innerText = "RAINFOREST";
                this.uiZone.className = "text-xs text-yellow-400 mt-1 uppercase tracking-widest font-bold";
                
                this.generateLevel(0);
                this.generateJungleBackground();
                this.triggerAlert("BONUS LEVEL", "WELCOME TO THE JUNGLE", "text-yellow-400", "jungle-text-shadow");
                AudioSys.playJungleEnter();
            }

            gameOver(reason) {
                // Check for Bonus Level Trigger
                if (!this.isBonusLevel && this.score <= CONFIG.bonusLevelThreshold && reason !== 'spaghettified') {
                    // Fall into Jungle
                    this.startBonusLevel();
                    return;
                }

                this.isRunning = false;
                AudioSys.playCrash();
                
                // Only update high score if main game
                if (!this.isBonusLevel && this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('space-dino-hs', this.highScore);
                    this.uiBest.innerText = Math.floor(this.highScore);
                }

                let reasonText = "SIGNAL LOST: VOID";
                if(reason === 'crash') reasonText = "HULL BREACH: COLLISION";
                if(reason === 'spaghettified') reasonText = "STATUS: SPAGHETTIFIED";
                if(this.isBonusLevel) reasonText = "JUNGLE RUN ENDED";

                document.getElementById('death-reason').innerText = reasonText;
                document.getElementById('final-score').innerText = `DISTANCE: ${Math.floor(this.score)}m`;
                
                this.screens.start.classList.add('hidden');
                this.screens.gameover.classList.remove('hidden');
                this.screens.container.classList.remove('opacity-0', 'pointer-events-none');
            }

            generateLevel(startX) {
                const lookAhead = this.dino ? this.dino.pos.x + this.width * 1.5 : this.width;
                const lastAnchor = this.anchors.length > 0 ? this.anchors[this.anchors.length-1] : { x: 0, y: 0 };
                
                if (lastAnchor.x < lookAhead) {
                    let currentX = lastAnchor.x;
                    if (currentX === 0) currentX = 200; 

                    while (currentX < lookAhead) {
                        const spacing = 120 + Math.random() * 150;
                        currentX += spacing;
                        const wave = Math.sin(currentX / 900) * 220; 
                        const noise = (Math.random() - 0.5) * 150;
                        let y = wave + noise;
                        if (y < -250) y = -250; 
                        if (y > 300) y = 300;   

                        this.anchors.push({ x: currentX, y: y, active: true });

                        if (this.isBonusLevel) {
                            // --- JUNGLE HAZARDS ---
                            // Frogs
                            if (Math.random() < 0.15) {
                                const hazX = currentX + spacing/2;
                                const hazY = y + 100 + (Math.random() * 100); 
                                this.hazards.push(new Hazard(hazX, hazY, 'frog'));
                            }
                            // Snakes
                            if (Math.random() < 0.1) {
                                this.hazards.push(new Hazard(currentX + 500, y - 50 + (Math.random()*100), 'snake'));
                            }
                            // Sloths
                            if (this.score > CONFIG.slothThreshold && Math.random() < 0.05) {
                                this.hazards.push(new Hazard(currentX + 500, y - 100, 'sloth'));
                            }
                        } else {
                            // --- SPACE HAZARDS ---
                            if (!this.dino.hasRider && (this.score - this.dino.lostRiderAt >= CONFIG.rescueDistance)) {
                                // Handled by Auto-Rescue logic now, but kept logic structure if needed
                            }

                            if (currentX > CONFIG.spaceThreshold) {
                                if (Math.random() < 0.2) {
                                    const hazX = currentX + spacing/2;
                                    const hazY = y + (Math.random() - 0.5) * 300;
                                    this.hazards.push(new Hazard(hazX, hazY, 'asteroid'));
                                }
                                if (Math.random() < 0.02) {
                                    this.hazards.push(new Hazard(currentX + 800, y - 200, 'comet'));
                                }
                            }
                            if (currentX > CONFIG.starThreshold) {
                                if (Math.random() < 0.04) { 
                                    this.hazards.push(new Hazard(currentX + 1000, y - 400, 'shootingStar'));
                                }
                            }
                            if (currentX > CONFIG.blackHoleThreshold) {
                                if (Math.random() < 0.01) { 
                                    this.hazards.push(new Hazard(currentX + 600, y + (Math.random()-0.5)*100, 'blackHole'));
                                }
                            }
                        }
                    }
                }

                if (this.dino) {
                    const cutoff = this.dino.pos.x - this.width;
                    this.anchors = this.anchors.filter(a => a.x > cutoff);
                    this.hazards = this.hazards.filter(h => h.x > cutoff && h.y < this.dino.pos.y + 1000);
                }
            }

            checkCollisions() {
                for (let i = this.hazards.length - 1; i >= 0; i--) {
                    let h = this.hazards[i];
                    if (!h.active) continue;

                    const dx = this.dino.pos.x - h.x;
                    const dy = this.dino.pos.y - h.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if (h.type === 'blackHole') {
                        if (dist < h.radius) {
                            this.dino.spaghettified = true;
                            this.gameOver('spaghettified');
                            return;
                        }
                    } else {
                        // General collision radius
                        let hitRadius = h.radius;
                        if(h.type === 'frog') hitRadius = 15;
                        if(h.type === 'snake') hitRadius = 12;
                        if(h.type === 'sloth') hitRadius = 30;

                        if (dist < this.dino.radius + hitRadius) {
                            if (this.dino.invulnerableTimer > 0) return; 

                            if (this.dino.hasRider) {
                                this.dino.loseRider(this.score);
                                h.active = false; 
                                
                                if (this.uiRider) {
                                    this.uiRider.innerText = "CO-PILOT: LOST";
                                    this.uiRider.className = "text-red-500 text-xs font-bold tracking-widest mt-1 blink";
                                }
                                this.triggerAlert("PILOT EJECTED", "SURVIVE FOR RESCUE", "text-red-500", "hazard-text-shadow");
                            } else {
                                this.gameOver('crash');
                                return;
                            }
                        }
                    }
                }
            }

            triggerAlert(title, subtitle, colorClass, shadowClass) {
                if (!this.uiAlertTitle || !this.uiAlertSub) return;
                this.uiAlertTitle.innerText = title;
                this.uiAlertTitle.className = `text-4xl ${colorClass} ${shadowClass} space-alert font-bold`;
                this.uiAlertSub.innerText = subtitle;
                this.uiSpaceAlert.classList.remove('hidden');
                setTimeout(() => this.uiSpaceAlert.classList.add('hidden'), 3000);
            }

            update() {
                if (!this.isRunning) return;

                this.dino.update(this.width, this.hazards);
                this.camera.update(this.dino.pos.x, this.dino.pos.y, this.width, this.height);
                this.generateLevel();
                
                this.hazards.forEach(h => h.update());
                this.checkCollisions();

                // Auto-Rescue Logic
                if (!this.dino.hasRider && (this.score - this.dino.lostRiderAt >= CONFIG.rescueDistance)) {
                    this.dino.recoverRider();
                    if (this.uiRider) {
                        this.uiRider.innerText = "CO-PILOT: ACTIVE";
                        this.uiRider.className = "text-green-400 text-xs font-bold tracking-widest mt-1";
                    }
                    this.triggerAlert("PILOT RETURNED", "SHIELDS RESTORED", "text-green-500", "rescue-text-shadow");
                }

                const dist = Math.floor(this.dino.pos.x / 10);
                if (dist > this.score) this.score = dist;
                if (this.uiScore) this.uiScore.innerHTML = `${Math.floor(this.score)}<span class="text-2xl">m</span>`;
                
                const speed = Math.sqrt(this.dino.vel.x**2 + this.dino.vel.y**2) * 3.6; 
                if (this.uiSpeed) this.uiSpeed.innerText = `${Math.floor(speed)} km/h`;
                
                // --- ZONE ALERTS (Space Only) ---
                if (!this.isBonusLevel) {
                    if (dist >= 1000 && dist < 2000) {
                        if (this.uiZone) {
                            this.uiZone.innerText = "ASTEROID BELT";
                            this.uiZone.className = "text-xs text-red-500 mt-1 uppercase tracking-widest font-bold";
                        }
                        if (this.alertState === 0) {
                            this.alertState = 1;
                            this.triggerAlert("ASTEROID BELT", "AVOID DEBRIS", "text-red-500", "hazard-text-shadow");
                            AudioSys.playSpaceEnter();
                        }
                    } else if (dist >= 2000 && dist < 5000) {
                        if (this.uiZone) {
                            this.uiZone.innerText = "METEOR SHOWER";
                            this.uiZone.className = "text-xs text-white mt-1 uppercase tracking-widest font-bold";
                        }
                        if (this.alertState === 1) {
                            this.alertState = 2;
                            this.triggerAlert("METEOR SHOWER", "EXTREME VELOCITY HAZARDS", "text-white", "star-text-shadow");
                            AudioSys.playSpaceEnter();
                        }
                    } else if (dist >= 5000) {
                        if (this.uiZone) {
                            this.uiZone.innerText = "EVENT HORIZON";
                            this.uiZone.className = "text-xs text-purple-400 mt-1 uppercase tracking-widest font-bold";
                        }
                        if (this.alertState === 2) {
                            this.alertState = 3;
                            AudioSys.playVoidHum();
                            this.triggerAlert("SINGULARITY DETECTED", "GRAVITY WELLS ACTIVE", "text-purple-500", "void-text-shadow");
                        }
                    }
                }

                if (this.dino.pos.y > 600) this.gameOver('void');
            }

            draw() {
                const dist = this.dino ? this.dino.pos.x : 0;
                
                if (this.isBonusLevel) {
                    // --- JUNGLE BACKGROUND (PARALLAX) ---
                    const grad = this.ctx.createLinearGradient(0, 0, 0, this.height);
                    grad.addColorStop(0, '#0f766e'); // Teal-ish sky
                    grad.addColorStop(1, '#064e3b'); // Dark Jungle Green
                    this.ctx.fillStyle = grad;
                    this.ctx.fillRect(0, 0, this.width, this.height);

                    // Clouds (parallax)
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    this.jungleClouds.forEach(cloud => {
                        cloud.x -= cloud.speed;
                        if(cloud.x + cloud.radius < 0) cloud.x = this.width + cloud.radius;
                        const x = (cloud.x - this.camera.x * 0.05) % (this.width + cloud.radius * 2);
                        let finalX = x;
                        if (finalX < -cloud.radius) finalX += (this.width + cloud.radius * 2);

                        this.ctx.beginPath();
                        this.ctx.arc(finalX, cloud.y, cloud.radius, 0, Math.PI*2);
                        this.ctx.arc(finalX + cloud.radius*0.6, cloud.y - cloud.radius*0.2, cloud.radius*0.7, 0, Math.PI*2);
                        this.ctx.arc(finalX - cloud.radius*0.6, cloud.y - cloud.radius*0.2, cloud.radius*0.7, 0, Math.PI*2);
                        this.ctx.fill();
                    });

                    // Back Trees (parallax)
                    this.ctx.fillStyle = '#022c22';
                    this.jungleTreesBack.forEach(tree => {
                        const x = (tree.x - this.camera.x * 0.1) % (this.width + tree.width*2);
                        let finalX = x;
                        if (finalX < -tree.width*2) finalX += (this.width + tree.width*2);
                        
                        // Trunk
                        this.ctx.fillRect(finalX, tree.y - tree.height, tree.width, tree.height);
                        // Foliage
                        this.ctx.beginPath();
                        this.ctx.arc(finalX + tree.width/2, tree.y - tree.height, tree.width*1.5, 0, Math.PI*2);
                        this.ctx.fill();
                    });

                    // Front Trees (parallax)
                    this.ctx.fillStyle = '#065f46';
                    this.jungleTreesFront.forEach(tree => {
                        const x = (tree.x - this.camera.x * 0.2) % (this.width + tree.width*2);
                        let finalX = x;
                        if (finalX < -tree.width*2) finalX += (this.width + tree.width*2);

                        // Trunk
                        this.ctx.fillRect(finalX, tree.y - tree.height, tree.width, tree.height);
                        // Foliage
                        this.ctx.beginPath();
                        this.ctx.arc(finalX + tree.width/2, tree.y - tree.height, tree.width*1.5, 0, Math.PI*2);
                        this.ctx.arc(finalX + tree.width/2 - tree.width, tree.y - tree.height + tree.width, tree.width, 0, Math.PI*2);
                        this.ctx.arc(finalX + tree.width/2 + tree.width, tree.y - tree.height + tree.width, tree.width, 0, Math.PI*2);
                        this.ctx.fill();
                    });
                    
                    // Jungle Floor Fog
                    this.ctx.fillStyle = 'rgba(6, 95, 70, 0.5)';
                    this.ctx.fillRect(0, this.height - 150, this.width, 150);

                } else {
                    // --- SPACE BACKGROUND ---
                    const transitionStart = 8000;
                    const transitionEnd = 12000;
                    let t = (dist - transitionStart) / (transitionEnd - transitionStart);
                    t = Math.max(0, Math.min(1, t));

                    const r = Math.floor(15 * (1-t));
                    const g = Math.floor(23 * (1-t));
                    const b = Math.floor(42 * (1-t));
                    this.ctx.fillStyle = `rgb(${r},${g},${b})`;
                    this.ctx.fillRect(0, 0, this.width, this.height);

                    // Stars (Space Only)
                    this.ctx.fillStyle = '#FFF';
                    this.stars.forEach(star => {
                        const px = (star.x - this.camera.x * (0.1 * star.depth)) % this.width;
                        const py = (star.y - this.camera.y * (0.1 * star.depth)) % this.height;
                        const finalX = px < 0 ? px + this.width : px;
                        const finalY = py < 0 ? py + this.height : py;
                        this.ctx.globalAlpha = star.alpha;
                        this.ctx.beginPath();
                        this.ctx.arc(finalX, finalY, star.size, 0, Math.PI*2);
                        this.ctx.fill();
                    });
                    this.ctx.globalAlpha = 1.0;
                }

                this.ctx.save();
                this.ctx.translate(-this.camera.x, -this.camera.y);

                this.hazards.sort((a,b) => {
                    const order = { 'blackHole': 0, 'rescuePod': 1, 'asteroid': 2, 'comet': 3, 'shootingStar': 4, 'snake': 3, 'frog': 4, 'sloth': 2 };
                    return order[a.type] - order[b.type];
                });
                this.hazards.forEach(h => h.draw(this.ctx));

                // Draw Tether / Vine
                if (this.dino && this.dino.grapplePoint) {
                    if (this.isBonusLevel) {
                        // VINE
                        this.ctx.strokeStyle = '#65a30d'; // Lime Green
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.moveTo(this.dino.pos.x, this.dino.pos.y);
                        // Beizer curve for organic vine look
                        const midX = (this.dino.pos.x + this.dino.grapplePoint.x) / 2;
                        const midY = (this.dino.pos.y + this.dino.grapplePoint.y) / 2 + 20; // Hang a bit
                        this.ctx.quadraticCurveTo(midX, midY, this.dino.grapplePoint.x, this.dino.grapplePoint.y);
                        this.ctx.stroke();
                    } else {
                        // LASER
                        this.ctx.strokeStyle = '#06b6d4'; 
                        this.ctx.lineWidth = 2;
                        this.ctx.shadowBlur = 10;
                        this.ctx.shadowColor = '#06b6d4';
                        this.ctx.beginPath();
                        this.ctx.moveTo(this.dino.pos.x, this.dino.pos.y);
                        this.ctx.lineTo(this.dino.grapplePoint.x, this.dino.grapplePoint.y);
                        this.ctx.stroke();
                        this.ctx.shadowBlur = 0; 
                        this.ctx.fillStyle = '#fff';
                        this.ctx.beginPath();
                        this.ctx.arc(this.dino.grapplePoint.x, this.dino.grapplePoint.y, 6, 0, Math.PI*2);
                        this.ctx.fill();
                    }
                }

                // Draw Anchors
                this.anchors.forEach(a => {
                    if (this.isBonusLevel) {
                        // JUNGLE FLOWER ANCHOR
                        this.ctx.fillStyle = '#f472b6'; // Pink
                        this.ctx.beginPath();
                        this.ctx.arc(a.x, a.y, 8, 0, Math.PI*2);
                        this.ctx.fill();
                        this.ctx.fillStyle = '#fef08a'; // Yellow center
                        this.ctx.beginPath();
                        this.ctx.arc(a.x, a.y, 4, 0, Math.PI*2);
                        this.ctx.fill();
                    } else {
                        // SPACE ORB
                        const glowSize = 10 + Math.sin(Date.now()/200)*3;
                        const grad = this.ctx.createRadialGradient(a.x, a.y, 2, a.x, a.y, glowSize);
                        grad.addColorStop(0, '#22d3ee'); 
                        grad.addColorStop(1, 'rgba(6, 182, 212, 0)');
                        this.ctx.fillStyle = grad;
                        this.ctx.beginPath();
                        this.ctx.arc(a.x, a.y, glowSize, 0, Math.PI*2);
                        this.ctx.fill();
                        this.ctx.fillStyle = '#cffafe';
                        this.ctx.beginPath();
                        this.ctx.arc(a.x, a.y, 3, 0, Math.PI*2);
                        this.ctx.fill();
                    }
                });

                if (this.dino) this.dino.draw(this.ctx, this.isBonusLevel);

                // Lava/Void Floor (Space Only)
                if (!this.isBonusLevel) {
                    const lavaY = 600;
                    if (this.camera.y + this.height > lavaY) {
                       const grad = this.ctx.createLinearGradient(0, lavaY, 0, lavaY + 200);
                       grad.addColorStop(0, `rgba(15, 23, 42, 1)`); 
                       grad.addColorStop(1, `rgba(6, 182, 212, 0.2)`);
                       this.ctx.fillStyle = grad;
                       this.ctx.fillRect(this.camera.x, lavaY, this.width, 200);
                    }
                }

                this.ctx.restore();
            }

            loop() {
                this.update();
                this.draw();
                requestAnimationFrame(this.loop);
            }
        }

        window.onload = () => {
            const game = new Game();
        };

    </script>
</body>
</html>
